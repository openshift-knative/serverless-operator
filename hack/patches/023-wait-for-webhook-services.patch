diff --git a/vendor/knative.dev/operator/pkg/reconciler/common/install.go b/vendor/knative.dev/operator/pkg/reconciler/common/install.go
index 4b3b3adaf..192571de8 100644
--- a/vendor/knative.dev/operator/pkg/reconciler/common/install.go
+++ b/vendor/knative.dev/operator/pkg/reconciler/common/install.go
@@ -20,12 +20,21 @@ import (
 	"context"
 	"fmt"
 	"strings"
+	"time"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/client-go/kubernetes/scheme"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/util/wait"
+	"k8s.io/apimachinery/pkg/api/errors"

 	mf "github.com/manifestival/manifestival"
 	"knative.dev/pkg/logging"

 	"knative.dev/operator/pkg/apis/operator/base"
 	"knative.dev/operator/pkg/apis/operator/v1beta1"
+
 )

 var (
@@ -33,6 +42,9 @@ var (
 	rolebinding     mf.Predicate = mf.Any(mf.ByKind("ClusterRoleBinding"), mf.ByKind("RoleBinding"))
 	webhook         mf.Predicate = mf.Any(mf.ByKind("MutatingWebhookConfiguration"), mf.ByKind("ValidatingWebhookConfiguration"))
 	gatewayNotMatch              = "no matches for kind \"Gateway\""
+	Interval = 10 * time.Second
+	// Timeout specifies the timeout for the function PollImmediate to reach a certain status.
+	Timeout                   = 5 * time.Minute
 )

 // Install applies the manifest resources for the given version and updates the given
@@ -63,6 +75,12 @@ func Install(ctx context.Context, manifest *mf.Manifest, instance base.KComponen

 		return fmt.Errorf("failed to apply non rbac manifest: %w", err)
 	}
+	if waitErr := wait.PollUntilContextTimeout(ctx, Interval, Timeout, true, func(_ context.Context) (bool, error) {
+		return checkWebhookServices(ctx, manifest, instance)
+	}); waitErr != nil {
+		return  fmt.Errorf("Webhook services are not ready: %w", waitErr)
+	}
+
 	if err := manifest.Filter(webhook).Apply(); err != nil {
 		status.MarkInstallFailed(err.Error())
 		return fmt.Errorf("failed to apply webhooks: %w", err)
@@ -83,3 +101,59 @@ func Uninstall(manifest *mf.Manifest) error {
 	}
 	return nil
 }
+
+func checkWebhookServices(ctx context.Context, manifest *mf.Manifest, instance base.KComponent) (bool, error) {
+	for _, u := range manifest.Filter(mf.All(mf.ByKind("Service"), byNameSuffix("webhook"))).Resources() {
+		resource, err := manifest.Client.Get(&u)
+		if err != nil {
+			if errors.IsNotFound(err) {
+				return false, nil
+			}
+			return false, err
+		}
+		svc := &corev1.Service{}
+		if err := scheme.Scheme.Convert(resource, svc, nil); err != nil {
+			return false, err
+		}
+		if ready, err := isSvcReady(ctx, manifest, svc); !ready {
+			return false, err
+		}
+	}
+	return true, nil
+}
+
+func isSvcReady(ctx context.Context, manifest *mf.Manifest, svc *corev1.Service) (bool, error) {
+	result := unstructured.Unstructured{}
+	result.SetName(svc.Name)
+	svcGvk := schema.GroupVersionKind{
+		Group:   corev1.SchemeGroupVersion.Group,
+		Version: corev1.SchemeGroupVersion.Version,
+		Kind:    "Endpoints",
+	}
+	result.SetGroupVersionKind(svcGvk)
+	result.SetNamespace(svc.Namespace)
+	endpointsU, err := manifest.Client.Get(&result)
+	if err != nil {
+		if errors.IsNotFound(err) {
+			return false, nil
+		}
+		return false, err
+	}
+	epts := &corev1.Endpoints{}
+	if err := scheme.Scheme.Convert(endpointsU, epts, nil); err != nil {
+		return false, err
+	}
+	for _, subset := range epts.Subsets {
+		if len(subset.Addresses) > 0 {
+			return true, nil // At least one endpoint is available
+		}
+	}
+	return false, nil
+}
+
+func byNameSuffix(suffix string) mf.Predicate {
+	return func(u *unstructured.Unstructured) bool {
+		return strings.HasSuffix(u.GetName(), suffix)
+	}
+}
+
