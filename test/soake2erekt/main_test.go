package soake2erekt

import (
	"context"
	"flag"
	"log"
	"os"
	"strconv"
	"testing"
	"time"

	corev1 "k8s.io/api/core/v1"
	"knative.dev/eventing/test/rekt/resources/channel_impl"
	"knative.dev/pkg/system"
	pkgTest "knative.dev/pkg/test"
	"knative.dev/reconciler-test/pkg/environment"
	"knative.dev/reconciler-test/pkg/feature"
	"knative.dev/reconciler-test/pkg/k8s"
	"knative.dev/reconciler-test/pkg/knative"
)

// var global environment.GlobalEnvironment

type SoakFlagsStruct struct {
	Duration     time.Duration
	Copies       int
	PollInterval time.Duration
	PollDuration time.Duration
}

var Flags SoakFlagsStruct

var global environment.GlobalEnvironment

// TestMain is the first entry point for `go test`.
func TestMain(m *testing.M) {
	channel_impl.EnvCfg.ChannelGK = "KafkaChannel.messaging.knative.dev"
	channel_impl.EnvCfg.ChannelV = "v1beta1"

	flag.DurationVar(&Flags.Duration, "soak-duration", 1*time.Hour, "Soak test duration")
	flag.IntVar(&Flags.Copies, "soak-copies", 1, "Number of copies for each soak test scenario")
	flag.DurationVar(&Flags.PollInterval, "soak-poll-interval", 5*time.Second, "Poll interval used in soak tests")
	flag.DurationVar(&Flags.PollDuration, "soak-poll-duration", 10*time.Minute, "Poll duration used in soak tests")

	restConfig, err := pkgTest.Flags.ClientConfig.GetRESTConfig()
	if err != nil {
		log.Fatal("Error building client config: ", err)
	}

	// Getting the rest config explicitly and passing it further will prevent re-initializing the flagset
	// in NewStandardGlobalEnvironment().
	global = environment.NewStandardGlobalEnvironment(func(cfg environment.Configuration) environment.Configuration {
		cfg.Config = restConfig
		return cfg
	})

	// Run the tests.
	os.Exit(m.Run())
}

func soakTestEnvironment(t *testing.T, namespace string) (context.Context, environment.Environment) {
	return global.Environment(
		environment.InNamespace(namespace),
		knative.WithKnativeNamespace(system.Namespace()),
		knative.WithLoggingConfig,
		knative.WithTracingConfig,
		k8s.WithEventListener,
		// Enables KnativeService in the scenario.
		//eventshub.WithKnativeServiceForwarder,
		environment.WithPollTimings(Flags.PollInterval, Flags.PollDuration),
		environment.WithTestLogger(t),
	)
}

/*
SoakFn represents part of the soak test to be run repeatedly, over a number of copies in parallel
The features are generated dynamically by a function, so that it is possible to generate unique resource names
for each test copy, or in each iteration
*/
type SoakFn func(copyID, iteration int) *feature.Feature

type SoakTest struct {
	/*
		Prefix to be used for namespaces. Actual test namespace is <prefix><copyId>
	*/
	NamespacePrefix string
	/*
		List of setup features generated by functions which will be invoked as Tests at the beginning of the soak test copy

		For simplicity (and reusability of the functions as both setup and iteration functions), the interface is the same for both setup and iteration functions,
		but for SetupFns, the `iteration` argument is undefined

		The features are executed in sequence
	*/
	SetupFns []SoakFn
	/*
		List of iteration features generated by functions which will be invoked as Tests at each soak test iteration for each soak test copy.
		The features are executed in sequence
	*/
	IterationFns []SoakFn
}

func RunSoakTest(t *testing.T, test SoakTest, copies int) {
	for copyID := 0; copyID < copies; copyID++ {
		copyID := copyID
		namespace := test.NamespacePrefix + strconv.Itoa(copyID)
		t.Run(namespace, func(t *testing.T) {
			t.Parallel()

			since := time.Now()

			ctx, env := soakTestEnvironment(t, namespace)

			// Execute the setup "features", store the references created during setup for cleanup at the end
			srefs := make([]corev1.ObjectReference, 0)
			for _, fn := range test.SetupFns {
				f := fn(copyID, -1)
				env.Test(ctx, t, f)

				if t.Failed() {
					return
				}

				srefs = append(srefs, f.References()...)
			}

			iteration := 0
			// Repeat the soak test for the duration specified by --soak-duration flag
			for since.Add(Flags.Duration).After(time.Now()) {
				// During each iteration, generate the "iteration" features and run them as Tests
				// Cleanup all resources for these features at the end of the iteration

				fs := make([]*feature.Feature, len(test.IterationFns))
				frefs := make([]corev1.ObjectReference, 0)
				for fi := 0; fi < len(test.IterationFns); fi++ {
					fs[fi] = test.IterationFns[fi](copyID, iteration)
					env.Test(ctx, t, fs[fi])
					if t.Failed() {
						return
					}

					frefs = append(frefs, fs[fi].References()...)
				}

				err := feature.DeleteResources(ctx, t, frefs)
				if err != nil {
					t.Fatalf("error deleting resources: %v", err)
				}

				iteration++
			}

			if iteration == 0 {
				t.Errorf("No iteration run")
			}

			// cleanup all the references from the setup phase
			err := feature.DeleteResources(ctx, t, srefs)
			if err != nil {
				t.Fatalf("error deleting resources: %v", err)
			}
			env.Finish()
		})
	}
}

func RunSoakTestWithDefaultCopies(t *testing.T, test SoakTest) {
	RunSoakTest(t, test, Flags.Copies)
}
