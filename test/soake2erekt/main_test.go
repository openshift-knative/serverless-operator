package soake2erekt

import (
	"context"
	"flag"
	"log"
	"os"
	"strconv"
	"testing"
	"time"

	corev1 "k8s.io/api/core/v1"
	"knative.dev/eventing/test/rekt/resources/channel_impl"
	"knative.dev/pkg/system"
	pkgTest "knative.dev/pkg/test"
	"knative.dev/reconciler-test/pkg/environment"
	"knative.dev/reconciler-test/pkg/feature"
	"knative.dev/reconciler-test/pkg/k8s"
	"knative.dev/reconciler-test/pkg/knative"
)

// var global environment.GlobalEnvironment

type SoakFlagsStruct struct {
	Duration time.Duration
	Copies   int
}

var Flags SoakFlagsStruct

var global environment.GlobalEnvironment

// TestMain is the first entry point for `go test`.
func TestMain(m *testing.M) {
	channel_impl.EnvCfg.ChannelGK = "KafkaChannel.messaging.knative.dev"
	channel_impl.EnvCfg.ChannelV = "v1beta1"

	flag.DurationVar(&Flags.Duration, "soak-duration", 1*time.Hour, "Soak test duration (defaults to 1 hour)")
	flag.IntVar(&Flags.Copies, "soak-copies", 1, "Number of copies for each soak test scenario (defaults to 1)")

	restConfig, err := pkgTest.Flags.ClientConfig.GetRESTConfig()
	if err != nil {
		log.Fatal("Error building client config: ", err)
	}

	// Getting the rest config explicitly and passing it further will prevent re-initializing the flagset
	// in NewStandardGlobalEnvironment().
	global = environment.NewStandardGlobalEnvironment(func(cfg environment.Configuration) environment.Configuration {
		cfg.Config = restConfig
		return cfg
	})

	// Run the tests.
	os.Exit(m.Run())
}

func soakTestEnvironment(t *testing.T, namespace string) (context.Context, environment.Environment) {
	return global.Environment(
		environment.InNamespace(namespace),
		knative.WithKnativeNamespace(system.Namespace()),
		knative.WithLoggingConfig,
		knative.WithTracingConfig,
		k8s.WithEventListener,
		// Enables KnativeService in the scenario.
		//eventshub.WithKnativeServiceForwarder,
		environment.WithPollTimings(5*time.Second, 4*time.Minute),
		environment.WithTestLogger(t),
	)
}

type SoakFn func(copyID, iteration int) *feature.Feature

type SoakTest struct {
	/*
		Prefix to be used for namespaces. Actual test namespace is <prefix><copyId>
	*/
	NamespacePrefix string
	/*
		List of setup features generated by functions which will be invoked as Tests at the beginning of the soak test instance
	*/
	SetupFns     []SoakFn
	IterationFns []SoakFn
}

func RunSoakTest(t *testing.T, test SoakTest, copies int) {
	for copyID := 0; copyID < copies; copyID++ {
		copyID := copyID
		namespace := test.NamespacePrefix + strconv.Itoa(copyID)
		t.Run(namespace, func(t *testing.T) {
			t.Parallel()

			since := time.Now()

			ctx, env := soakTestEnvironment(t, namespace)

			// Execute the setup "features"
			for _, fn := range test.SetupFns {
				env.Test(ctx, t, fn(copyID, -1))
				if t.Failed() {
					return
				}
			}

			iteration := 0
			// Repeat the soak test for the duration specified by --soak-duration flag
			for since.Add(Flags.Duration).After(time.Now()) {
				// During each iteration, generate the "iteration" features and run them as Tests
				// Cleanup all resources for these features at the end of the iteration

				fs := make([]*feature.Feature, len(test.IterationFns))
				frefs := make([]corev1.ObjectReference, 0)
				for fi := 0; fi < len(test.IterationFns); fi++ {
					fs[fi] = test.IterationFns[fi](copyID, iteration)
					env.Test(ctx, t, fs[fi])
					if t.Failed() {
						return
					}

					frefs = append(frefs, fs[fi].References()...)
				}

				err := feature.DeleteResources(ctx, t, frefs)
				if err != nil {
					t.Fatalf("error deleting resources: %v", err)
				}

				iteration++
			}

			if iteration == 0 {
				t.Errorf("No iteration run")
			}

			err := feature.DeleteResources(ctx, t, env.References())
			if err != nil {
				t.Fatalf("error deleting resources: %v", err)
			}
			env.Finish()
		})
	}
}

func RunSoakTestWithDefaultCopies(t *testing.T, test SoakTest) {
	RunSoakTest(t, test, Flags.Copies)
}
