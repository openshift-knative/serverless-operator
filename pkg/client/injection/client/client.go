// Code generated by injection-gen. DO NOT EDIT.

package client

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"

	versioned "github.com/openshift-knative/serverless-operator/pkg/client/clientset/versioned"
	typedconfigv1 "github.com/openshift-knative/serverless-operator/pkg/client/clientset/versioned/typed/config/v1"
	typedroutev1 "github.com/openshift-knative/serverless-operator/pkg/client/clientset/versioned/typed/route/v1"
	v1 "github.com/openshift/api/config/v1"
	routev1 "github.com/openshift/api/route/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	watch "k8s.io/apimachinery/pkg/watch"
	discovery "k8s.io/client-go/discovery"
	dynamic "k8s.io/client-go/dynamic"
	rest "k8s.io/client-go/rest"
	injection "knative.dev/pkg/injection"
	dynamicclient "knative.dev/pkg/injection/clients/dynamicclient"
	logging "knative.dev/pkg/logging"
)

func init() {
	injection.Default.RegisterClient(withClientFromConfig)
	injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} {
		return Get(ctx)
	})
	injection.Dynamic.RegisterDynamicClient(withClientFromDynamic)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context {
	return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}

func withClientFromDynamic(ctx context.Context) context.Context {
	return context.WithValue(ctx, Key{}, &wrapClient{dyn: dynamicclient.Get(ctx)})
}

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface {
	untyped := ctx.Value(Key{})
	if untyped == nil {
		if injection.GetConfig(ctx) == nil {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/openshift-knative/serverless-operator/pkg/client/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
		} else {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/openshift-knative/serverless-operator/pkg/client/clientset/versioned.Interface from context.")
		}
	}
	return untyped.(versioned.Interface)
}

type wrapClient struct {
	dyn dynamic.Interface
}

var _ versioned.Interface = (*wrapClient)(nil)

func (w *wrapClient) Discovery() discovery.DiscoveryInterface {
	panic("Discovery called on dynamic client!")
}

func convert(from interface{}, to runtime.Object) error {
	bs, err := json.Marshal(from)
	if err != nil {
		return fmt.Errorf("Marshal() = %w", err)
	}
	if err := json.Unmarshal(bs, to); err != nil {
		return fmt.Errorf("Unmarshal() = %w", err)
	}
	return nil
}

// ConfigV1 retrieves the ConfigV1Client
func (w *wrapClient) ConfigV1() typedconfigv1.ConfigV1Interface {
	return &wrapConfigV1{
		dyn: w.dyn,
	}
}

type wrapConfigV1 struct {
	dyn dynamic.Interface
}

func (w *wrapConfigV1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapConfigV1) APIServers() typedconfigv1.APIServerInterface {
	return &wrapConfigV1APIServerImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "apiservers",
		}),
	}
}

type wrapConfigV1APIServerImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.APIServerInterface = (*wrapConfigV1APIServerImpl)(nil)

func (w *wrapConfigV1APIServerImpl) Create(ctx context.Context, in *v1.APIServer, opts metav1.CreateOptions) (*v1.APIServer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "APIServer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1APIServerImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1APIServerImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.APIServer, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.APIServerList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServerList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.APIServer, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) Update(ctx context.Context, in *v1.APIServer, opts metav1.UpdateOptions) (*v1.APIServer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "APIServer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) UpdateStatus(ctx context.Context, in *v1.APIServer, opts metav1.UpdateOptions) (*v1.APIServer, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "APIServer",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.APIServer{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1APIServerImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Authentications() typedconfigv1.AuthenticationInterface {
	return &wrapConfigV1AuthenticationImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "authentications",
		}),
	}
}

type wrapConfigV1AuthenticationImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.AuthenticationInterface = (*wrapConfigV1AuthenticationImpl)(nil)

func (w *wrapConfigV1AuthenticationImpl) Create(ctx context.Context, in *v1.Authentication, opts metav1.CreateOptions) (*v1.Authentication, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Authentication",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Authentication{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1AuthenticationImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1AuthenticationImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Authentication, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Authentication{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.AuthenticationList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.AuthenticationList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Authentication, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Authentication{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) Update(ctx context.Context, in *v1.Authentication, opts metav1.UpdateOptions) (*v1.Authentication, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Authentication",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Authentication{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) UpdateStatus(ctx context.Context, in *v1.Authentication, opts metav1.UpdateOptions) (*v1.Authentication, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Authentication",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Authentication{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1AuthenticationImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Builds() typedconfigv1.BuildInterface {
	return &wrapConfigV1BuildImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "builds",
		}),
	}
}

type wrapConfigV1BuildImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.BuildInterface = (*wrapConfigV1BuildImpl)(nil)

func (w *wrapConfigV1BuildImpl) Create(ctx context.Context, in *v1.Build, opts metav1.CreateOptions) (*v1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1BuildImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1BuildImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Build, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.BuildList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.BuildList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Build, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) Update(ctx context.Context, in *v1.Build, opts metav1.UpdateOptions) (*v1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) UpdateStatus(ctx context.Context, in *v1.Build, opts metav1.UpdateOptions) (*v1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1BuildImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) ClusterOperators() typedconfigv1.ClusterOperatorInterface {
	return &wrapConfigV1ClusterOperatorImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "clusteroperators",
		}),
	}
}

type wrapConfigV1ClusterOperatorImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ClusterOperatorInterface = (*wrapConfigV1ClusterOperatorImpl)(nil)

func (w *wrapConfigV1ClusterOperatorImpl) Create(ctx context.Context, in *v1.ClusterOperator, opts metav1.CreateOptions) (*v1.ClusterOperator, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterOperator",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperator{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ClusterOperatorImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ClusterOperatorImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.ClusterOperator, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperator{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ClusterOperatorList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperatorList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.ClusterOperator, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperator{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) Update(ctx context.Context, in *v1.ClusterOperator, opts metav1.UpdateOptions) (*v1.ClusterOperator, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterOperator",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperator{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) UpdateStatus(ctx context.Context, in *v1.ClusterOperator, opts metav1.UpdateOptions) (*v1.ClusterOperator, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterOperator",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterOperator{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterOperatorImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) ClusterVersions() typedconfigv1.ClusterVersionInterface {
	return &wrapConfigV1ClusterVersionImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "clusterversions",
		}),
	}
}

type wrapConfigV1ClusterVersionImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ClusterVersionInterface = (*wrapConfigV1ClusterVersionImpl)(nil)

func (w *wrapConfigV1ClusterVersionImpl) Create(ctx context.Context, in *v1.ClusterVersion, opts metav1.CreateOptions) (*v1.ClusterVersion, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterVersion",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersion{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ClusterVersionImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ClusterVersionImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.ClusterVersion, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersion{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ClusterVersionList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersionList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.ClusterVersion, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersion{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) Update(ctx context.Context, in *v1.ClusterVersion, opts metav1.UpdateOptions) (*v1.ClusterVersion, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterVersion",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersion{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) UpdateStatus(ctx context.Context, in *v1.ClusterVersion, opts metav1.UpdateOptions) (*v1.ClusterVersion, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ClusterVersion",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ClusterVersion{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ClusterVersionImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Consoles() typedconfigv1.ConsoleInterface {
	return &wrapConfigV1ConsoleImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "consoles",
		}),
	}
}

type wrapConfigV1ConsoleImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ConsoleInterface = (*wrapConfigV1ConsoleImpl)(nil)

func (w *wrapConfigV1ConsoleImpl) Create(ctx context.Context, in *v1.Console, opts metav1.CreateOptions) (*v1.Console, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Console",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Console{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ConsoleImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ConsoleImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Console, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Console{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ConsoleList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ConsoleList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Console, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Console{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) Update(ctx context.Context, in *v1.Console, opts metav1.UpdateOptions) (*v1.Console, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Console",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Console{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) UpdateStatus(ctx context.Context, in *v1.Console, opts metav1.UpdateOptions) (*v1.Console, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Console",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Console{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ConsoleImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) DNSs() typedconfigv1.DNSInterface {
	return &wrapConfigV1DNSImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "dnss",
		}),
	}
}

type wrapConfigV1DNSImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.DNSInterface = (*wrapConfigV1DNSImpl)(nil)

func (w *wrapConfigV1DNSImpl) Create(ctx context.Context, in *v1.DNS, opts metav1.CreateOptions) (*v1.DNS, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "DNS",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNS{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1DNSImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1DNSImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.DNS, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNS{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.DNSList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNSList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.DNS, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNS{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) Update(ctx context.Context, in *v1.DNS, opts metav1.UpdateOptions) (*v1.DNS, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "DNS",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNS{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) UpdateStatus(ctx context.Context, in *v1.DNS, opts metav1.UpdateOptions) (*v1.DNS, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "DNS",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.DNS{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1DNSImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) FeatureGates() typedconfigv1.FeatureGateInterface {
	return &wrapConfigV1FeatureGateImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "featuregates",
		}),
	}
}

type wrapConfigV1FeatureGateImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.FeatureGateInterface = (*wrapConfigV1FeatureGateImpl)(nil)

func (w *wrapConfigV1FeatureGateImpl) Create(ctx context.Context, in *v1.FeatureGate, opts metav1.CreateOptions) (*v1.FeatureGate, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "FeatureGate",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGate{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1FeatureGateImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1FeatureGateImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.FeatureGate, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGate{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.FeatureGateList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGateList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.FeatureGate, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGate{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) Update(ctx context.Context, in *v1.FeatureGate, opts metav1.UpdateOptions) (*v1.FeatureGate, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "FeatureGate",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGate{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) UpdateStatus(ctx context.Context, in *v1.FeatureGate, opts metav1.UpdateOptions) (*v1.FeatureGate, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "FeatureGate",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.FeatureGate{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1FeatureGateImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Images() typedconfigv1.ImageInterface {
	return &wrapConfigV1ImageImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "images",
		}),
	}
}

type wrapConfigV1ImageImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ImageInterface = (*wrapConfigV1ImageImpl)(nil)

func (w *wrapConfigV1ImageImpl) Create(ctx context.Context, in *v1.Image, opts metav1.CreateOptions) (*v1.Image, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Image",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Image{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ImageImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ImageImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Image, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Image{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ImageList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Image, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Image{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) Update(ctx context.Context, in *v1.Image, opts metav1.UpdateOptions) (*v1.Image, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Image",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Image{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) UpdateStatus(ctx context.Context, in *v1.Image, opts metav1.UpdateOptions) (*v1.Image, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Image",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Image{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) ImageContentPolicies() typedconfigv1.ImageContentPolicyInterface {
	return &wrapConfigV1ImageContentPolicyImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "imagecontentpolicies",
		}),
	}
}

type wrapConfigV1ImageContentPolicyImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ImageContentPolicyInterface = (*wrapConfigV1ImageContentPolicyImpl)(nil)

func (w *wrapConfigV1ImageContentPolicyImpl) Create(ctx context.Context, in *v1.ImageContentPolicy, opts metav1.CreateOptions) (*v1.ImageContentPolicy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ImageContentPolicy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ImageContentPolicyImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ImageContentPolicyImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.ImageContentPolicy, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ImageContentPolicyList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicyList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.ImageContentPolicy, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) Update(ctx context.Context, in *v1.ImageContentPolicy, opts metav1.UpdateOptions) (*v1.ImageContentPolicy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ImageContentPolicy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) UpdateStatus(ctx context.Context, in *v1.ImageContentPolicy, opts metav1.UpdateOptions) (*v1.ImageContentPolicy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "ImageContentPolicy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ImageContentPolicy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ImageContentPolicyImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Infrastructures() typedconfigv1.InfrastructureInterface {
	return &wrapConfigV1InfrastructureImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "infrastructures",
		}),
	}
}

type wrapConfigV1InfrastructureImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.InfrastructureInterface = (*wrapConfigV1InfrastructureImpl)(nil)

func (w *wrapConfigV1InfrastructureImpl) Create(ctx context.Context, in *v1.Infrastructure, opts metav1.CreateOptions) (*v1.Infrastructure, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Infrastructure",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Infrastructure{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1InfrastructureImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1InfrastructureImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Infrastructure, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Infrastructure{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.InfrastructureList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.InfrastructureList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Infrastructure, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Infrastructure{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) Update(ctx context.Context, in *v1.Infrastructure, opts metav1.UpdateOptions) (*v1.Infrastructure, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Infrastructure",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Infrastructure{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) UpdateStatus(ctx context.Context, in *v1.Infrastructure, opts metav1.UpdateOptions) (*v1.Infrastructure, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Infrastructure",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Infrastructure{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1InfrastructureImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Ingresses() typedconfigv1.IngressInterface {
	return &wrapConfigV1IngressImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "ingresses",
		}),
	}
}

type wrapConfigV1IngressImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.IngressInterface = (*wrapConfigV1IngressImpl)(nil)

func (w *wrapConfigV1IngressImpl) Create(ctx context.Context, in *v1.Ingress, opts metav1.CreateOptions) (*v1.Ingress, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Ingress",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Ingress{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1IngressImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1IngressImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Ingress, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Ingress{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.IngressList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.IngressList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Ingress, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Ingress{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) Update(ctx context.Context, in *v1.Ingress, opts metav1.UpdateOptions) (*v1.Ingress, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Ingress",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Ingress{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) UpdateStatus(ctx context.Context, in *v1.Ingress, opts metav1.UpdateOptions) (*v1.Ingress, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Ingress",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Ingress{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1IngressImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Networks() typedconfigv1.NetworkInterface {
	return &wrapConfigV1NetworkImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "networks",
		}),
	}
}

type wrapConfigV1NetworkImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.NetworkInterface = (*wrapConfigV1NetworkImpl)(nil)

func (w *wrapConfigV1NetworkImpl) Create(ctx context.Context, in *v1.Network, opts metav1.CreateOptions) (*v1.Network, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Network",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Network{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1NetworkImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1NetworkImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Network, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Network{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.NetworkList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.NetworkList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Network, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Network{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) Update(ctx context.Context, in *v1.Network, opts metav1.UpdateOptions) (*v1.Network, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Network",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Network{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) UpdateStatus(ctx context.Context, in *v1.Network, opts metav1.UpdateOptions) (*v1.Network, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Network",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Network{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1NetworkImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) OAuths() typedconfigv1.OAuthInterface {
	return &wrapConfigV1OAuthImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "oauths",
		}),
	}
}

type wrapConfigV1OAuthImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.OAuthInterface = (*wrapConfigV1OAuthImpl)(nil)

func (w *wrapConfigV1OAuthImpl) Create(ctx context.Context, in *v1.OAuth, opts metav1.CreateOptions) (*v1.OAuth, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OAuth",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuth{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1OAuthImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1OAuthImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.OAuth, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuth{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.OAuthList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuthList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.OAuth, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuth{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) Update(ctx context.Context, in *v1.OAuth, opts metav1.UpdateOptions) (*v1.OAuth, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OAuth",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuth{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) UpdateStatus(ctx context.Context, in *v1.OAuth, opts metav1.UpdateOptions) (*v1.OAuth, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OAuth",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OAuth{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OAuthImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) OperatorHubs() typedconfigv1.OperatorHubInterface {
	return &wrapConfigV1OperatorHubImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "operatorhubs",
		}),
	}
}

type wrapConfigV1OperatorHubImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.OperatorHubInterface = (*wrapConfigV1OperatorHubImpl)(nil)

func (w *wrapConfigV1OperatorHubImpl) Create(ctx context.Context, in *v1.OperatorHub, opts metav1.CreateOptions) (*v1.OperatorHub, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OperatorHub",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHub{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1OperatorHubImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1OperatorHubImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.OperatorHub, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHub{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.OperatorHubList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHubList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.OperatorHub, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHub{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) Update(ctx context.Context, in *v1.OperatorHub, opts metav1.UpdateOptions) (*v1.OperatorHub, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OperatorHub",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHub{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) UpdateStatus(ctx context.Context, in *v1.OperatorHub, opts metav1.UpdateOptions) (*v1.OperatorHub, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "OperatorHub",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.OperatorHub{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1OperatorHubImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Projects() typedconfigv1.ProjectInterface {
	return &wrapConfigV1ProjectImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "projects",
		}),
	}
}

type wrapConfigV1ProjectImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ProjectInterface = (*wrapConfigV1ProjectImpl)(nil)

func (w *wrapConfigV1ProjectImpl) Create(ctx context.Context, in *v1.Project, opts metav1.CreateOptions) (*v1.Project, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Project",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Project{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ProjectImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ProjectImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Project, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Project{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ProjectList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ProjectList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Project, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Project{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) Update(ctx context.Context, in *v1.Project, opts metav1.UpdateOptions) (*v1.Project, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Project",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Project{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) UpdateStatus(ctx context.Context, in *v1.Project, opts metav1.UpdateOptions) (*v1.Project, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Project",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Project{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProjectImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Proxies() typedconfigv1.ProxyInterface {
	return &wrapConfigV1ProxyImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "proxies",
		}),
	}
}

type wrapConfigV1ProxyImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.ProxyInterface = (*wrapConfigV1ProxyImpl)(nil)

func (w *wrapConfigV1ProxyImpl) Create(ctx context.Context, in *v1.Proxy, opts metav1.CreateOptions) (*v1.Proxy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Proxy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Proxy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1ProxyImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1ProxyImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Proxy, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Proxy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.ProxyList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.ProxyList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Proxy, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Proxy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) Update(ctx context.Context, in *v1.Proxy, opts metav1.UpdateOptions) (*v1.Proxy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Proxy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Proxy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) UpdateStatus(ctx context.Context, in *v1.Proxy, opts metav1.UpdateOptions) (*v1.Proxy, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Proxy",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Proxy{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1ProxyImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapConfigV1) Schedulers() typedconfigv1.SchedulerInterface {
	return &wrapConfigV1SchedulerImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "config.openshift.io",
			Version:  "v1",
			Resource: "schedulers",
		}),
	}
}

type wrapConfigV1SchedulerImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedconfigv1.SchedulerInterface = (*wrapConfigV1SchedulerImpl)(nil)

func (w *wrapConfigV1SchedulerImpl) Create(ctx context.Context, in *v1.Scheduler, opts metav1.CreateOptions) (*v1.Scheduler, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Scheduler",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Scheduler{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapConfigV1SchedulerImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapConfigV1SchedulerImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Scheduler, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Scheduler{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) List(ctx context.Context, opts metav1.ListOptions) (*v1.SchedulerList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.SchedulerList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Scheduler, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Scheduler{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) Update(ctx context.Context, in *v1.Scheduler, opts metav1.UpdateOptions) (*v1.Scheduler, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Scheduler",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Scheduler{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) UpdateStatus(ctx context.Context, in *v1.Scheduler, opts metav1.UpdateOptions) (*v1.Scheduler, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "config.openshift.io",
		Version: "v1",
		Kind:    "Scheduler",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1.Scheduler{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapConfigV1SchedulerImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

// RouteV1 retrieves the RouteV1Client
func (w *wrapClient) RouteV1() typedroutev1.RouteV1Interface {
	return &wrapRouteV1{
		dyn: w.dyn,
	}
}

type wrapRouteV1 struct {
	dyn dynamic.Interface
}

func (w *wrapRouteV1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapRouteV1) Routes(namespace string) typedroutev1.RouteInterface {
	return &wrapRouteV1RouteImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "route.openshift.io",
			Version:  "v1",
			Resource: "routes",
		}),

		namespace: namespace,
	}
}

type wrapRouteV1RouteImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedroutev1.RouteInterface = (*wrapRouteV1RouteImpl)(nil)

func (w *wrapRouteV1RouteImpl) Create(ctx context.Context, in *routev1.Route, opts metav1.CreateOptions) (*routev1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "route.openshift.io",
		Version: "v1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapRouteV1RouteImpl) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapRouteV1RouteImpl) Get(ctx context.Context, name string, opts metav1.GetOptions) (*routev1.Route, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) List(ctx context.Context, opts metav1.ListOptions) (*routev1.RouteList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.RouteList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *routev1.Route, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) Update(ctx context.Context, in *routev1.Route, opts metav1.UpdateOptions) (*routev1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "route.openshift.io",
		Version: "v1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) UpdateStatus(ctx context.Context, in *routev1.Route, opts metav1.UpdateOptions) (*routev1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "route.openshift.io",
		Version: "v1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &routev1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapRouteV1RouteImpl) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}
